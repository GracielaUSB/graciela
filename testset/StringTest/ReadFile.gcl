
/*% LANGUAGE MemoryOperations %*/
/*% LANGUAGE NoAssertions %*/



include "String"

program Program begin

abstract ListA(T)
begin
  /* ListA Tariables */
  var seq : sequence of T;
  {repinv true repinv}
  /* ListA Trocedures and functions */
  proc push_back (ref list : ListA(T), in e : T)
    {pre true pre}
    {post #list.seq == #list'.seq+1 /\ list.seq[#list.seq-1] == e post}
end

type List(T) implements ListA(T)
begin
  /* List variables */
  var size := 0 : int;
  var max_size := 0 : int;
  var elems := null : T*;
  var m : Mem(T);

  {repinv elems == null ==> size == 0 repinv}
  {coupinv true coupinv}
  where {
    seq := << i : int | 0 <= i /\ i < size | elems[i] >>
  }

  /* List procedures and functions */
  proc push_back (ref list : List(T), in e : T)
    {pre true pre}
    {post list.size == list'.size + 1 /\ list.elems[list.size-1] == e post}
    |[ 
      if list.max_size == 0 -> 

        malloc (list.m, 2, list.elems);
        list.max_size := 2;
      [] list.size == list.max_size -> 
        var aux : T*;
        var i := 0 : int;

        list.max_size := list.max_size * 2;
        malloc(list.m, list.max_size, aux);
        {inv true inv}
        {bound list.size - i bound}
        do i < list.size ->
          aux[i] := list.elems[i];
          i := i+1;
        od;
        free(list.elems);
        list.elems := aux
      [] otherwise -> skip
      fi;
      list.elems[list.size] := e;
      list.size := list.size + 1
    ]|

  proc showList (ref list : List(T))
    {pre  true  pre}
    {post true post}
    |[ var i := 0 : int;
       {inv true inv}
       {bound list.size - i bound}
       do i < list.size ->
         write(list.elems[i]);
         i := i+1;
       od;
      writeln()
    ]|

  proc deleteList (ref list : List(T))
    {pre  true  pre}
    {post true post}
    |[  free(list.elems); 
    ]|

end

alias StringB := List(char);

proc readFile (ref str : StringB)
  {pre  true  pre}
  {post true post}
  |[ var c := ' ' : char 
   ; {inv true inv}
     {bound 1 bound}
     do c != '\0' -> read(c) from "hola.t"; push_back(str, c) od
  ]|

alias Tokens := List(StringB*);


proc deleteListTokens (ref list : Tokens)
    {pre  true  pre}
    {post true post}
    |[ if list.elems != null ->
          var i := 0 : int
          ; {inv true inv}
            {bound 1 bound}
            do i < list.size -> 
              if list.elems[i] != null -> 
                deleteList(*list.elems[i]);
                free(list.elems[i])
              [] otherwise -> skip
              fi;
              i := i + 1;
            od;
          free(list.elems)
       [] otherwise -> skip
       fi
    ]|


func strlen( x : char*, i : int) -> int
  {pre   x != null  pre}
  {post  true post}
  {bound MAX_INT - i bound}
  |[
    if x[i] == '\0' -> 0
    [] otherwise -> strlen(x,i+1) + 1
    fi
  ]|


proc compStrings (in s1 : char*, in s2 : char*, out b : boolean )
  var l1, l2 := strlen(s1,0), strlen(s2,0) : int;
  {pre  s1 != null /\ s2 != null pre}
  {post b === (% forall i : int 
                  | 0 <= i /\ i <= l1 min l2
                  | s1[i] == s2[i] %) post}
  |[ b := true;
     if l1 == l2 ->   
       var i := trace((l1 min l2)-1) : int; 
       {inv  true inv}
       {bound i bound}
       do i >= 0 -> 
          if s1[i] != s2[i] -> b,i := false, -1
          [] otherwise -> i := i-1;
          fi
       od
     [] otherwise -> b := false
     fi

  ]|

proc tokenizer (in str : StringB, out tokens : Tokens)
  {pre  true  pre}
  {post true post}
  |[ var i := 0 : int;
    {inv true inv}
    {bound str.size - i bound}
    do i < str.size ->
       write(str.elems[i]);
       i := i + 1;
    od
  ]|

main
  |[ 
    var str  : StringB;
    var t  : Tokens;
    var b : boolean;
    var v : array[2,2,2] of array[10,10] of array[2,2] of int;
    v[1,1,1][9,9][1,1] := 1010101;
    compStrings("jamon", "holas", b);
    writeln("Are equal: ", b);
    readFile(str);
    tokenizer(str, t);
    deleteListTokens(t);
    skip
  ]|
end